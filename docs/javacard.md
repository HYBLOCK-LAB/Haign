# Java Card Coding Considerations

This document outlines key differences and caveats developers should be aware of when transitioning from standard Java to Java Card.

## Abstraction
| Topic                        | Java                         | Java Card                                     | Notes                                             |
|-----------------------------|------------------------------|------------------------------------------------|---------------------------------------------------|
| Memory Management           | Automatic (Garbage Collected)| Manual; no GC; EEPROM/RAM distinction          | Use `JCSystem.makeTransient...` for RAM           |
| Data Types                  | `int`, `long`, `float` etc.  | Only `byte`, `short`                           | Use fixed-size arrays for structures              |
| Object Allocation           | Allowed at any time          | Only at install-time (for persistent objects)  | No dynamic allocation during runtime              |
| Exception Handling          | Extensive use acceptable     | Try to minimize; expensive on smartcards       | Avoid try-catch inside loops                      |
| Standard Libraries          | Full Java SE                 | Only Java Card API (subset)                    | No `java.util`, `java.io`, etc.                   |
| Class Size Limit            | No limit                     | CAP file class size limit (e.g. 64KB)          | Split logic if needed                             |
| String Handling             | `String` supported           | No native `String` class                       | Use byte arrays instead                           |
| Logging / Debugging         | System.out/Logging available | No console output or logging                   | Use status words or APDU responses for debugging  |
| File I/O                    | Available                    | Not supported                                  | No filesystem on card                             |
| Static Initialization       | Commonly used                | Must be carefully handled to avoid EEPROM wear | Avoid frequent writes                             |
| Threads / Concurrency       | Supported                    | Not supported                                  | Single-threaded execution only                    |
| API Usage                   | Flexible                     | Use `Util`, `ISO7816`, `JCSystem`, etc.        | Rely on provided helper classes                   |


# APDU Instruction Codes and Status Words
## Instruction Codes

### 0. Code Types 
> Code type follow the [SLIP ‑ 0044](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)

| INS               | Coin                 | 
|-------------------|----------------------|
| **`0x00`**        | Bitcoin              | 
| **`0x3c`**        | Ethereum             | 
| **`0x90`**        | XRP                  |  

### 1. PIN/Authentication Instructions (0x2X)
| INS               | Constant                     | Meaning                                  | 
|-------------------|------------------------------|------------------------------------------|
| **`0x20`**        | `INS_VERIFY_PIN`             | Verifies the user’s PIN: compares the 4‑byte PIN in the data field against the stored PIN.<br>• On success: resets retry counter.<br>• On failure: increments retry counter. |
| **`0x22`**        | `INS_CHANHE_PIN`             | Changes the PIN: supplies old and new PIN in one command. <br>• Data field contains: [old‑PIN length][old‑PIN][new‑PIN length][new‑PIN] |
| **`0x24`**        | `INS_RESET_PIN`              |  Resets or unblocks the PIN (e.g., after administrator authentication). No data field is required.                                | 

### 2. Key Management Instructions (0x3X)
| INS               | Constant                     | Meaning                                  | 
|-------------------|------------------------------|------------------------------------------|
| **`0x30`**        | `INS_GENERATE_KEY`           |	Receives the coin type in the Lc field and a 16‑byte UUID in the data field; generates a new asymmetric key pair inside the card. <br>The private key is stored securely, and the public key can be retrieved with `INS_GET_PUBKEY`.<br> Example: **`80 30 10 00 10 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0`** |
| **`0x32`**        | `INS_GET_PUBKEY`             |  Receives the coin type in the Lc field and a 16‑byte UUID in the data field; retrieves the uncompressed public key corresponding to the key pair generated by `INS_GENERATE_KEY`. <br>Returns the public key in the response data field.<br>Example: **`80 32 00 00 10 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0`** |
| **`0x34`**        | `INS_GET_ALL_PUBKEY`             | Returns list of public key and UUID in the response data field.<br> [number of keys(1byte)][iterate of [sum of UUID length and public key length][UUID][public key]]   |
| **`0x36`**        | `INS_SIGN`                   |  Signs the APDU data field, which contains the content to be signed (e.g., transaction or message blob); <br>Returns the signature in the response data field. |

### 3. Address Retrieval Instructions (0x4X)
| INS               | Constant                     | Meaning                                  | 
|-------------------|------------------------------|------------------------------------------|
| **`0x40`**        | `INS_GET_ADDRESS`            |	Receives a 16‑byte UUID in the data field; derives and returns the associated wallet address (e.g., encoded public address) in the response data field..<br> Example: **`80 40 10 00 10 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0`** |
| **`0x42`**        | `INS_LIST_ADDRESSES`         |  Retrieves all stored wallet entries; each entry in the response contains: <br>• 16‑byte UUID<br>• Wallet address string<br>• 1‑byte code type (coin type)<br>No input data is required. |

### 4. Metadata Instructions (0x5X)
| INS               | Constant                     | Meaning                                  |
|-------------------|------------------------------|------------------------------------------|
| **`0x50`**        | `INS_GET_EEPROM_FREE`        |	Returns the amount of free EEPROM memory remaining on the card as a 2‑byte big‑endian unsigned integer in the response data field. No input data is required. |

### 5. Sedd (0x6X)
| 0x60 | INS_SET_MASTER | Receives a 64‑byte seed generated externally from a BIP‑39 mnemonic. This seed is used to initialize the master key for BIP‑32/44 hierarchical key derivation. <br>The seed is not stored in EEPROM and is retained only in internal memory for secure derivation of hardened child keys via derivePath.<br>Lc must be 0x40 (64), and Data must contain the [64‑byte seed].<br>Example: 80 60 00 00 40 <64-byte SEED> |


## Status Words
### Custom
| Status Code       | Constant                   | Meaning                                                                                                                             | 
|-------------------|----------------------------|-------------------------------------------------------------------------------------------------------------------------------------|
| **`0x6F11`**      | `ILLEGAL_VALUE`            |	The provided data value is invalid or out of the allowed range (e.g., unsupported key length or parameter).                        |
| **`0x6F12`**      | `UNINITIALIZED_KEY`        |	Attempted to use a key object before initializing it with a valid key pair.                                                        |
| **`0x6F13`**      | `NO_SUCH_ALGORITHM`        |	The requested cryptographic algorithm or transformation is not supported by the card.                                              |
| **`0x6F14`**      | `INVALID_INIT`             |	Failed to initialize the cryptographic operation with the given parameters (e.g., incorrect algorithm mode or invalid key params). |
| **`0x6F15`**      | `ILLEGAL_USE`              |	The requested operation is not allowed in the current state or context (e.g., invoking a sign operation on a non‑signing key).     |
| **`0x6F16`**      | `KEY_ALREADY_EXISTS`       |	Key alreay exists when try to generate key pair.     |
| **`0x6F30`**      | `OUT_OF_INDEX`             |	The index is out of range for array.  |
| **`0x6F50`**      | `UNEXPECTED_ERROR`         | occured Unexpected error     |


### ISO7816
| Status Code       | Constant                           | Meaning                                                                                            | 
|-------------------|------------------------------------|----------------------------------------------------------------------------------------------------|
| **`0x6700`**      | `SW_WRONG_LENGTH`                  | The length of the command data (Lc) or expected response (Le) does not match the expected value.   |
| **`0x6982`**      | `SW_SECURITY_STATUS_NOT_SATISFIED` | A required security condition (e.g. PIN verification or secure channel) has not been met.          |
| **`0x6983`**      | `SW_FILE_INVALID`                  | The referenced file or object is not in a valid state for the requested operation.                 |
| **`0x6984`**      | `SW_DATA_INVALID`                  | The data field contains invalid or malformed data for this command.                                |
| **`0x6985`**      | `SW_CONDITIONS_NOT_SATISFIED`      | A precondition for the command (other than security) has not been satisfied.                       |
| **`0x6A80`**      | `SW_WRONG_DATA`                    | The parameters in the data field are incorrect or unsupported.                                     |
| **`0x6A81`**      | `SW_FUNC_NOT_SUPPORTED`            | The requested function or instruction is not supported by this applet.                             |
| **`0x6A82`**      | `SW_FILE_NOT_FOUND`                | The specified file or object could not be found.                                                   |
| **`0x6A83`**      | `SW_RECORD_NOT_FOUND`              | The requested record in the currently selected file does not exist.                                |
| **`0x6A84`**      | `SW_FILE_FULL`                     | There is no more space in the file or object to store additional data.                             |
| **`0x6A86`**      | `SW_INCORRECT_P1P2`                | The combination of P1 and P2 parameters is not valid for this instruction.                         |
| **`0x6A88`**      | `SW_WRONG_P1P2`                    | One or both of the P1/P2 parameters are outside the allowed range for this command.                |
| **`0x6D00`**      | `SW_INS_NOT_SUPPORTED`             | The INS byte in the command header is not recognized or implemented.                               |
| **`0x6E00`**      | `SW_CLA_NOT_SUPPORTED`             | The CLA byte in the command header is not supported by the card.                                   |







