# Java Card Coding Considerations

This document outlines key differences and caveats developers should be aware of when transitioning from standard Java to Java Card.

## Abstraction
| Topic                        | Java                         | Java Card                                | Notes |
|-----------------------------|------------------------------|------------------------------------------|-------|
| Memory Management           | Automatic (Garbage Collected)| Manual; no GC; EEPROM/RAM distinction     | Use `JCSystem.makeTransient...` for RAM |
| Data Types                  | `int`, `long`, `float` etc.  | Only `byte`, `short`                     | Use fixed-size arrays for structures |
| Object Allocation           | Allowed at any time          | Only at install-time (for persistent objects) | No dynamic allocation during runtime |
| Exception Handling          | Extensive use acceptable     | Try to minimize; expensive on smartcards | Avoid try-catch inside loops |
| Standard Libraries          | Full Java SE                 | Only Java Card API (subset)              | No `java.util`, `java.io`, etc. |
| Class Size Limit            | No limit                     | CAP file class size limit (e.g. 64KB)    | Split logic if needed |
| String Handling             | `String` supported           | No native `String` class                 | Use byte arrays instead |
| Logging / Debugging         | System.out/Logging available | No console output or logging             | Use status words or APDU responses for debugging |
| File I/O                    | Available                    | Not supported                            | No filesystem on card |
| Static Initialization       | Commonly used                | Must be carefully handled to avoid EEPROM wear | Avoid frequent writes |
| Threads / Concurrency       | Supported                    | Not supported                            | Single-threaded execution only |
| API Usage                   | Flexible                     | Use `Util`, `ISO7816`, `JCSystem`, etc.  | Rely on provided helper classes |


# APDU Instruction Codes and Status Words
## Instruction Codes

### 0. Code Types
| INS               | Coin                 | 
|-------------------|----------------------|
| **`0x01`**        | Bitcoin              | 
| **`0x02`**        | Ethereum             | 
| **`0x03`**        | XRP                  |  

### 1. PIN/Authentication Instructions (0x2X)
| INS               | Constant                     | Meaning                                  | 
|-------------------|------------------------------|------------------------------------------|
| **`0x20`**        | `INS_VERIFY_PIN`             | Verifies the user’s PIN: compares the 4‑byte PIN in the data field against the stored PIN.<br>• On success: resets retry counter.<br>• On failure: increments retry counter. |
| **`0x22`**        | `INS_CHANHE_PIN`             | Changes the PIN: supplies old and new PIN in one command. <br>• Data field contains: [old‑PIN length][old‑PIN][new‑PIN length][new‑PIN] |
| **`0x24`**        | `INS_RESET_PIN`              |  Resets or unblocks the PIN (e.g., after administrator authentication). No data field is required.                                | 

### 2. Key Management Instructions (0x3X)
| INS               | Constant                     | Meaning                                  | 
|-------------------|------------------------------|------------------------------------------|
| **`0x30`**        | `INS_GENERATE_KEY`           |	Receives the coin type in the Lc field and a 16‑byte UUID in the data field; generates a new asymmetric key pair inside the card. <br>The private key is stored securely, and the public key can be retrieved with `INS_GET_PUBKEY`.<br> Example: **`80 30 10 00 10 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0`** |
| **`0x32`**        | `INS_GET_PUBKEY`             |  Receives the coin type in the Lc field and a 16‑byte UUID in the data field; retrieves the uncompressed public key corresponding to the key pair generated by `INS_GENERATE_KEY`. <br>Returns the public key in the response data field.<br>Example: **`80 32 00 00 10 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0`** |
| **`0x34`**        | `INS_SIGN`                   |  Signs the APDU data field, which contains the content to be signed (e.g., transaction or message blob); <br>Returns the signature in the response data field. |

### 3. Address Retrieval Instructions (0x4X)
| INS               | Constant                     | Meaning                                  | 
|-------------------|------------------------------|------------------------------------------|
| **`0x40`**        | `INS_GET_ADDRESS`            |	Receives a 16‑byte UUID in the data field; derives and returns the associated wallet address (e.g., encoded public address) in the response data field..<br> Example: **`80 40 10 00 10 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0`** |
| **`0x42`**        | `INS_LIST_ADDRESSES`         |  Retrieves all stored wallet entries; each entry in the response contains: <br>• 16‑byte UUID<br>• Wallet address string<br>• 1‑byte code type (coin type)<br>No input data is required. |

### 4. Metadata Instructions (0x5X)
| INS               | Constant                     | Meaning                                  |
|-------------------|------------------------------|------------------------------------------|
| **`0x50`**        | `INS_GET_EEPROM_FREE`        |	Returns the amount of free EEPROM memory remaining on the card as a 2‑byte big‑endian unsigned integer in the response data field. No input data is required. |



## Status Words

| Status Code       | Constant                   | Meaning                                                                                                                             | 
|-------------------|----------------------------|-------------------------------------------------------------------------------------------------------------------------------------|
| **`0x6F 0x11`**   | `ILLEGAL_VALUE`            |	The provided data value is invalid or out of the allowed range (e.g., unsupported key length or parameter).                        |
| **`0x6F 0x12`**   | `UNINITIALIZED_KEY`        |	Attempted to use a key object before initializing it with a valid key pair.                                                        |
| **`0x6F 0x13`**   | `NO_SUCH_ALGORITHM`        |	The requested cryptographic algorithm or transformation is not supported by the card.                                              |
| **`0x6F 0x14`**   | `INVALID_INIT`             |	Failed to initialize the cryptographic operation with the given parameters (e.g., incorrect algorithm mode or invalid key params). |
| **`0x6F 0x15`**   | `ILLEGAL_USE`              |	The requested operation is not allowed in the current state or context (e.g., invoking a sign operation on a non‑signing key).     |
